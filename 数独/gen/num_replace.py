"""
    完整数独生产算法1：替换数字
    首先需要一个完整数独，然后产生一个一维数组例如【9,8,7,6,5,4,3,2,1】，将数独中的1替换成数组中的第一个数
    本例中就是将1替换成9,3替换成7，以此类推。
    9！ =  362880， 使用此方法理论上可以产生362880个数组不同但结构相同的数独。

    小知识：
    数独中的数字排列千变万化，那么究竟有多少种终盘的数字组合呢？
    6,670,903,752,021,072,936,960（约为6.67×10的21次方）种组合，
    2005年由Bertram Felgenhauer和Frazer Jarvis计算出该数字，并将计算方法发布在他们网站上，
    如果将等价终盘（如旋转、翻转、行行对换，数字对换等变形）不计算，则有5,472,730,538个组合。
    数独终盘的组合数量都如此惊人，那么数独题目数量就更加不计其数了，
    因为每个数独终盘又可以制作出无数道合格的数独题目。
"""
EXISTING_SUDOKU = [1, 2, 3, 4, 5, 6, 7, 8, 9,
                   4, 5, 6, 7, 8, 9, 1, 2, 3,
                   7, 8, 9, 1, 2, 3, 4, 5, 6,
                   2, 1, 4, 3, 6, 5, 8, 9, 7,
                   3, 6, 5, 8, 9, 7, 2, 1, 4,
                   8, 9, 7, 2, 1, 4, 3, 6, 5,
                   5, 3, 1, 6, 4, 2, 9, 7, 8,
                   6, 4, 2, 9, 7, 8, 5, 3, 1,
                   9, 7, 8, 5, 3, 1, 6, 4, 2]

def random_list():
    """
    随机生成一个1到9的排列，返回一个列表
    :return:
    """
    return [9, 7, 8, 5, 3, 4, 1, 2, 6]


def replace_num(list):
    seed = random_list()
    return [seed[i - 1] for i in list]


def main():
    ns = replace_num(EXISTING_SUDOKU)
    print(EXISTING_SUDOKU)
    print(ns)


if __name__ == '__main__':
    main()
